Bit Operation Notes

Counting Bits

while(j != 0){                
    if((j&1) == 1)
          c++;
    j = j >> 1 ;
}



find unique number/character in an array -- use xor. 
for(int a : nums) xor ^= a;
Two unique number - use xor, divide it based in bit position and do xor. 
1. find xor of all element in array
2. find set(1) bit position in xor value. (xor is set only when both operand is different )
3. from the array separate each number to it respective part of the section.

Missing number 0 to n

for(int i=0; i < nums.length; i++)
        xor = xor ^ i ^ nums[i];

Distinct Char between the strings
 for(int i=0; i< s.length(); i++)   c ^= s.charAt(i);
 for(int i=0; i< t.length(); i++)   c ^= t.charAt(i);


Reverse bits 
   int result = 0;
    for(int i=0; i<32; i++){
        result = result << 1;
        result += n&1;
        n = n >> 1;
    }
    return result;

Number Complement
1. Count bit

    while(n > 0){
        bitCount++;
        n = n >> 1;
    }

2. calculate all bit set value 

    long all_bit_set = (long) Math.pow(2, bitCount) - 1;

3. xor num with all bit set
  
    num ^ (int) all_bit_set;


LinkedList Notes

Convert binary number in a List to Integer
 
Math.pow(2,result[1]+1) * head.val ;

Middle of Linked List
	- Fast and slow pointer

while(fast != null && fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
}

Reverse  a Linked List 
1.Iterative

   while(current.next != null){
     forward = current.next ;
     current.next = previous;   
     previous = current; 
     current = forward;
   }
    head = current;
    head.next = previous;

2. Recusrsion

if(head.next == null)
      return head;
newHead = reverseList(head.next);
    head.next.next = head;
    head.next = null ;

Remove Duplicates in a sorted List
Two pointer method.

    ListNode prev = head;
    ListNode current = head.next;
   while(current != null){
        if(current.val != prev.val ){
            prev.next = current;
            prev = current;
        }
        current = current.next;
    }
    prev.next = current;

Linked List Cycle

Fast and slow pointer method

   while(fast != null && fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
        if(fast == slow)
            return true;
    }

Palindrome Linked List

1. find middle node
2. reverse second half of the list
3. compare the second half with first half.

    while(rHead != null){
        if(current.val != rHead.val)
            return false;
       rHead = rHead.next;
        current = current.next;
    }


Swap Nodes in Pairs
1. get previous part last node.
2. current part first node 
3. reverse the current part
4. assign current part reversed first node to previous part last node's next.
5. assign next part first node to reversed last node of current part's next. 

   while(current != null){
        ListNode lastNodeOfFirstPart = prev;
        ListNode lastNodeOfSubList = current;
        ListNode next = null;
       for(int i=0 ; i < 2 && current != null; i++){
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
       if(lastNodeOfFirstPart != null)
            lastNodeOfFirstPart.next = prev;
        else
            head = prev;
       lastNodeOfSubList.next = current;
       prev = lastNodeOfSubList;
    }

Sort List 

Merge sort algorithm

1. split the list into two halves
2. sort each half 
3. merge each half 
4. do this recursively for each half. Go to Step 1 and continue till single element in the half.

   ListNode prev = null, fast = head, slow = head;
    while(fast != null && fast.next != null){
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
   prev.next = null; 
   ListNode l1 = sortList(head);
   ListNode l2 = sortList(slow);
   return merge(l1,l2);
private ListNode merge(ListNode l1, ListNode l2){
    ListNode l = new ListNode(0), p=l;
    while(l1 != null && l2 != null){
        if(l1.val < l2.val){
            p.next = l1;
            l1 = l1.next;
        }else{
            p.next = l2;
            l2 = l2.next;
        }
        p = p.next;
    }
    if(l1 != null)
        p.next = l1;
    if(l2 != null)
        p.next = l2;
    return l.next;
}

Reverse Part of Linked List

    ListNode current = head;
     ListNode prev = null;
    for(int i=0; i< m-1 && current != null ; i++){
       prev = current;
       current= current.next;
    }
    ListNode lastOfFirstPart = prev;
    ListNode next = null;
    ListNode startOfSubList = current;
    for(int i=0; i < n-m+1 && current != null ; i++){
        next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    if(lastOfFirstPart != null)
        lastOfFirstPart.next = prev;
    else
        head = prev;
    startOfSubList.next = current;



Return List Cycle  first Node

1. detect cycle
2. find cycle length
3. move the pointer to cycle length from head.
4. iterate till both pointer same.

    ListNode pointer1 = head;
    ListNode pointer2 = head;
    while(l > 0){           
        pointer1 = pointer1.next;
         l--;
     }
   while(pointer1 != pointer2){
        pointer1 = pointer1.next;
        pointer2 = pointer2.next;
    }

Remove Nth node from end of the list

1. finally p1 value is null and p2 is in the before of delete node.
   
         ListNode p = new ListNode(0);
    ListNode p2 = p,  p1 = p;
    p.next = head;
   while(p1 != null){
        p1 = p1.next;
        if(n < 0){
            p2 = p2.next;
        }else
            n--;
    }        
    p2.next = p2.next.next;   

Reorder List
Given 1->2->3->4, reorder it to 1->4->2->3.

    ListNode h = head;
    while(fast != null && fast.next != null){
      fast = fast.next.next;
      slow = slow.next;
    }
    ListNode r = reverse(slow);
    while(h != null && r != null){
      ListNode temp = h.next;
      h.next = r;
      h = temp;       
      temp = r.next;
      r.next = h;
      r = temp;
    }       
    if (h != null)
        h.next = null;

Add Two Numbers
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8

ListNode r = new ListNode(0) ;
    ListNode r1 = r ;
    boolean first = true;        
    while(a1 != null || a2 != null){
        sum = sum / 10;            
        if(a1 != null){
            sum = sum + a1.val;
            a1 = a1.next;
        }
        if(a2 != null){
            sum = sum + a2.val;
            a2 = a2.next;
        }
        r.next = new ListNode(sum>=10 ? sum-10 : sum );
        r = r.next;           
    }
    if((sum / 10) != 0)
        r.next = new ListNode(sum / 10);

Rotate List
Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL

int l = 1;
    ListNode lastNode = head;
    while(lastNode.next != null){
        lastNode = lastNode.next;
        l++;
    }
    lastNode.next = head;
    k %=l;
    int req = l - k ;
    ListNode current = head;
    for(int i=0; i<req-1 && current != null;i++){
        current = current.next;
    }
    head = current.next;
    current.next = null;

Reverse Nodes in k-Group
Given this linked list: 1->2->3->4->5
For k = 2, you should return: 2->1->4->3->5
For k = 3, you should return: 3->2->1->4->5

        int l = 1 ;
        ListNode current = head;
        ListNode prev = null;
        while(current.next != null){
            l++;
            current = current.next;
        }
        l =  l - (l%k);
        System.out.println(l);
        int n = 0;
        current = head;
        while(n<l){          
            ListNode next = null;
            ListNode lastOfFirstPart = prev;
            ListNode startOfSubList = current;
            for(int i=0; i < k && current != null ; i++){
                next = current.next;
                current.next = prev;
                prev = current;
                current = next;                 
            }
            n += k;
            if(lastOfFirstPart != null)
                lastOfFirstPart.next = prev;
            else
                head = prev;
            startOfSubList.next = current;           
            prev = startOfSubList;
        }

Trees

Range Sum of BST
Input: root = [10,5,15,3,7,null,18], L = 7, R = 15
Output: 32

    if(root == null)
        return 0;
    int sum = 0;
    if(root.left != null)
        sum += rangeSumBST(root.left, L,R);
    if(root.val >= L && root.val <= R)
        sum = sum + root.val;
    if(root.right != null)
        sum += rangeSumBST(root.right, L,R);

Merge Two Binary Trees
Input: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
Output: 
Merged tree:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7

	if (t1 == null && t2 == null) return null;
	int val = (t1 == null ? 0 : t1.val) + (t2 == null ? 0 : t2.val); 
    TreeNode newNode = new TreeNode(val);
	newNode.left = mergeTrees(t1 == null ? null : t1.left, t2==null ? null : t2.left);
    newNode.right = mergeTrees(t1 == null ? null : t1.right, t2==null ? null : t2.right);
	return newNode;  
	
Search in a Binary Search Tree

Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to search: 2
You should return this subtree:
      2     
     / \   
    1   3

	TreeNode subTree = null;
    if(root == null)
        return root;
	if(val < root.val ){
        if(root.left != null)
            subTree = searchBST(root.left, val);
	}
    else if(val > root.val ){
        if(root.right != null)
            subTree = searchBST(root.right, val);            
    }
    else
        subTree = root;
	return subTree;

Maximum Depth of Binary Tree

Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.

    queue.offer(root);
    while(!queue.isEmpty()){
        maxDepth++;
        int levelSize = queue.size();
        for(int i=0; i<levelSize ; i++){
            TreeNode node = queue.poll();
            // if(node.left==null && node.right == null)
            //     return minDepth;
            if(node.left != null)
                queue.offer(node.left);
            if(node.right != null)
                queue.offer(node.right);
        }
    }

Average of Levels in Binary Tree
Input:
    3
   / \
  9  20
    /  \
   15   7
Output: [3, 14.5, 11]

    queue.offer(root);
    // boolean leftToRight = true;
    while(!queue.isEmpty()){
        int levelSize = queue.size();
        // List<Integer> levelLst = new LinkedList();           
        double sum = 0;
        for(int i = 0; i<levelSize ; i++){
            TreeNode node = queue.poll();      
            sum += node.val;                   
            if(node.left != null)
                queue.offer(node.left);
            if(node.right != null)
                queue.offer(node.right);                
        }
        double d = sum / levelSize;
        // leftToRight = !leftToRight;
        list.add(d);
    }        

Sum of Left Leaves

    3
   / \
  9  20
    /  \
   15   7
There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.

   if(root.left != null){
        if(root.left.left == null && root.left.right == null)
            sum += root.left.val;
        else
            sum += sumOfLeftLeaves(root.left);
    }        
    sum += sumOfLeftLeaves(root.right);

Binary Tree Level Order Traversal II

Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]

    queue.offer(root);
    while(!queue.isEmpty()){
        int levelSize = queue.size();
        List<Integer> levelLst = new ArrayList();
        for(int i = 0; i < levelSize ; i++){
            TreeNode node = queue.poll();
            levelLst.add(node.val);
            if(node.left != null)
                queue.offer(node.left);
            if(node.right != null)
                queue.offer(node.right);
        }
        list.add(0,levelLst);
    }

Path Sum

Given the below binary tree and sum = 22,
      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.

if(sum == root.val && root.left == null && root.right == null)
        return true;        
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum- root.val);

Minimum Depth of Binary Tree

Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its minimum depth = 2.

    queue.offer(root);
    while(!queue.isEmpty()){
        minDepth++;
        int levelSize = queue.size();
        for(int i=0; i<levelSize ; i++){
            TreeNode node = queue.poll();
            if(node.left==null && node.right == null)
                return minDepth;
            if(node.left != null)
                queue.offer(node.left);
            if(node.right != null)
                queue.offer(node.right);
        }
    }

 Insert into a Binary Search Tree

Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
You can return this binary search tree:
         4
       /   \
      2     7
     / \   /
    1   3 5

    if(val < root.val ){
        if(root.left != null)
            insertIntoBST(root.left, val);
        else
            root.left = new TreeNode(val);
    }
    else if(val > root.val ){
        if(root.right != null)
            insertIntoBST(root.right, val);
        else
            root.right = new TreeNode(val);
    }

Binary Tree Inorder Traversal
Input: [1,null,2,3]
   1
    \
     2
    /
   3
Output: [1,3,2]

	    if(root.left != null){
        getSoln(list,root.left);
    }
    list.add(root.val);
    if(root.right != null)
        getSoln(list,root.right);
	
Binary Tree Level Order Traversal

Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
    queue.offer(root);
    while(!queue.isEmpty()){
        int levelSize = queue.size();
        List<Integer> levelLst = new ArrayList();
        for(int i = 0; i<levelSize ; i++){
            TreeNode node = queue.poll();
            levelLst.add(node.val);
            if(node.left != null)
                queue.offer(node.left);
            if(node.right != null)
                queue.offer(node.right);
        }
        list.add(levelLst);
    }
  //other solution -- mix of bfs and dfs
    if(h >= list.size() )
        list.add(new LinkedList());
    list.get(h).add(root.val);
    getSoln(list,root.left , h+1);
    getSoln(list,root.right, h+1);

Unique Binary Search Trees
Input: 3
Output: 5


dp[1] = 1;
    for(int i=2; i<=n ; i++){
        int sum = 0;
        for(int j = 1; j<=i ; j++){
            int l = (j - 1 == 0 ? 1 : j-1);
            int r = (i - j == 0 ? 1 : i - j) ;
            sum += dp[l] * dp[r];
            // System.out.println(sum);
        }
        dp[i] = sum;
    } 

 Binary Tree Zigzag Level Order Traversal
